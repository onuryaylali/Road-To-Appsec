# February 19, 2026: Cryptographic Fundamentals - Encoding, Hashing & KDFs

> **Goal:** Distinguishing between data representation and cryptographic protection, focusing on modern password-hashing standards.

---

## 1. The Trinity of Data Transformation
Clarified the functional differences often confused in entry-level AppSec:
* **Encoding:** Transforming data for compatibility (e.g., **Base64** for URL safety). Provides **zero** security.
* **Hashing:** A one-way, deterministic function used for integrity and password storage.
* **Encryption:** A two-way function (reversible with a key) used for confidentiality.

## 2. Hashing Vulnerabilities & Modern Mitigation
Analyzed why traditional hashing (MD5, SHA-1, SHA-256) is insufficient for password storage.
* **The Speed Problem:** These algorithms are designed to be fast, making them vulnerable to massive GPU/ASIC-accelerated brute-force attacks.
* **Rainbow Tables:** Pre-computed tables of hashes. Mitigated by **Salting** (unique random data per user) and **Peppering** (a secret value stored outside the DB).

## 3. Key Derivation Functions (KDFs) & Memory Hardness
Researched "adaptive" hashing algorithms that increase attacker costs:
* **Argon2id:** The current industry gold standard. It provides resistance against both GPU-based cracking (memory-hardness) and side-channel attacks.
* **bcrypt:** Uses the Blowfish cipher to incorporate a "Work Factor" (cost), allowing developers to increase hashing time as hardware gets faster.
* **scrypt:** Specifically designed to require large amounts of RAM, making it prohibitively expensive to crack using custom hardware like FPGAs.

## 4. Summary & Reflection
In Application Security, "rolling your own crypto" is the ultimate anti-pattern. Secure architecture relies on utilizing vetted KDFs like **Argon2id** and understanding that security is a function of time and resource cost, not just mathematical complexity.